package co.csadev.kellocharts.util

import kotlin.math.ceil
import kotlin.math.floor
import kotlin.math.log10
import kotlin.math.pow
import kotlin.math.roundToInt

object FloatUtils {
    @Suppress("MagicNumber")
    private val POW10 = intArrayOf(1, 10, 100, 1000, 10000, 100000, 1000000)

    /**
     * Returns next bigger double value considering precision of the argument.
     */
    private fun nextUp(d: Double): Double {
        var dub = d
        return if (java.lang.Double.isNaN(dub) || dub == java.lang.Double.POSITIVE_INFINITY) {
            dub
        } else {
            dub += 0.0
            java.lang.Double.longBitsToDouble(java.lang.Double.doubleToRawLongBits(dub) + if (dub >= 0.0) +1 else -1)
        }
    }

    /**
     * Rounds the given number to the given number of significant digits.
     * Based on an answer on [Stack Overflow](http://stackoverflow.com/questions/202302).
     */
    private fun roundToOneSignificantFigure(num: Double): Float {
        val d = ceil(log10(if (num < 0) -num else num).toFloat().toDouble()).toFloat()
        val power = 1 - d.toInt()
        val magnitude = 10.0.pow(power.toDouble()).toFloat()
        val shifted = (num * magnitude).roundToInt()
        return shifted / magnitude
    }

    /**
     * Formats a float value to the given number of decimals. Returns the length of the string. The string begins at
     * [endIndex] - [return value] and ends at [endIndex]. It's up to you to check indexes correctness.
     * Parameter [endIndex] can be helpful when you want to append some text to formatted value.
     *
     * @return number of characters of formatted value
     */
    fun formatFloat(
        formattedValue: CharArray,
        value: Float,
        endIndex: Int,
        digits: Int,
        separator: Char
    ): Int {
        var floatVal = value
        var valDigits = digits
        if (valDigits >= POW10.size) {
            formattedValue[endIndex - 1] = '.'
            return 1
        }
        var negative = false
        if (floatVal == 0f) {
            formattedValue[endIndex - 1] = '0'
            return 1
        }
        if (floatVal < 0) {
            negative = true
            floatVal = -floatVal
        }
        if (valDigits > POW10.size) {
            valDigits = POW10.size - 1
        }
        floatVal *= POW10[valDigits].toFloat()
        var lVal = floatVal.roundToInt().toLong()
        var index = endIndex - 1
        var charsNumber = 0
        while (lVal != 0L || charsNumber < valDigits + 1) {
            val digit = (lVal % 10).toInt()
            lVal /= 10
            formattedValue[index--] = (digit + '0'.code).toChar()
            charsNumber++
            if (charsNumber == valDigits) {
                formattedValue[index--] = separator
                charsNumber++
            }
        }
        if (formattedValue[index + 1] == separator) {
            formattedValue[index--] = '0'
            charsNumber++
        }
        if (negative) {
            formattedValue[index] = '-'
            charsNumber++
        }
        return charsNumber
    }

    /**
     * Computes the set of axis labels to show given start and stop boundaries and an ideal number of stops between
     * these boundaries.
     *
     * @param start     The minimum extreme (e.g. the left edge) for the axis.
     * @param stop      The maximum extreme (e.g. the right edge) for the axis.
     * @param steps     The ideal number of stops to create. This should be based on available screen space; the more
     * space
     * there is, the more stops should be shown.
     * @param outValues The destination [AxisAutoValues] object to populate.
     */
    fun computeAutoGeneratedAxisValues(
        start: Float,
        stop: Float,
        steps: Int,
        outValues: AxisAutoValues
    ) {
        val range = (stop - start).toDouble()
        if (steps == 0 || range <= 0) {
            outValues.values = floatArrayOf()
            outValues.valuesNumber = 0
            return
        }

        val rawInterval = range / steps
        var interval = roundToOneSignificantFigure(rawInterval).toDouble()
        val intervalMagnitude = 10.0.pow(log10(interval).toInt().toDouble())
        val intervalSigDigit = (interval / intervalMagnitude).toInt()
        if (intervalSigDigit > 5) {
            // Use one order of magnitude higher, to avoid intervals like 0.9 or 90
            interval = floor(10 * intervalMagnitude)
        }

        val first = ceil(start / interval) * interval
        val last = nextUp(floor(stop / interval) * interval)

        var valuesNum = 0
        var intervalValue: Double = first
        while (intervalValue <= last) {
            ++valuesNum
            intervalValue += interval
        }

        outValues.valuesNumber = valuesNum

        if (outValues.values.size < valuesNum) {
            // Ensure stops contains at least numStops elements.
            outValues.values = FloatArray(valuesNum)
        }

        intervalValue = first
        var valueIndex = 0
        while (valueIndex < valuesNum) {
            outValues.values[valueIndex] = intervalValue.toFloat()
            intervalValue += interval
            ++valueIndex
        }

        if (interval < 1) {
            outValues.decimals = ceil(-log10(interval)).toInt()
        } else {
            outValues.decimals = 0
        }
    }
}
